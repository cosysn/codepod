# CLI SSH Connection Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Implement full SSH connection capability in CLI to connect to sandboxes with interactive shell and single command execution.

**Architecture:** Use `ssh2` library for SSH connections with `node-pty` for interactive shell support. Connect to sandbox using token as password, support both interactive sessions and single command execution.

**Tech Stack:**
- `ssh2`: SSH client library
- `node-pty`: PTY for interactive shell
- `ora`: Loading spinners
- `inquirer`: Interactive prompts

---

## Task 1: Add SSH Dependencies

**Files:**
- Modify: `apps/cli/package.json`

**Step 1: Add ssh2 dependency**

```json
{
  "dependencies": {
    "ssh2": "^1.15.0"
  },
  "devDependencies": {
    "@types/ssh2": "^1.15.0"
  }
}
```

**Step 2: Install dependencies**

Run: `cd apps/cli && npm install`

**Step 3: Verify installation**

Run: `npm list ssh2`
Expected: `ssh2@^1.15.0` in dependencies

---

## Task 2: Create SSH Service Module

**Files:**
- Create: `apps/cli/src/services/ssh.ts`

**Step 1: Write the failing test**

```typescript
// apps/cli/src/services/ssh.test.ts
import { SSHService, SSHConfig } from './ssh';

describe('SSHService', () => {
  it('should create connection config', () => {
    const config: SSHConfig = {
      host: 'localhost',
      port: 22,
      username: 'user',
      password: 'token',
    };
    const service = new SSHService(config);
    expect(service).toBeDefined();
  });
});
```

**Step 2: Run test to verify it fails**

Run: `cd apps/cli && npm test -- src/services/ssh.test.ts`
Expected: FAIL (file does not exist)

**Step 3: Implement SSH service**

```typescript
// apps/cli/src/services/ssh.ts
import { Client, ConnectConfig, ClientChannel } from 'ssh2';
import { EventEmitter } from 'events';

export interface SSHConfig {
  host: string;
  port: number;
  username: string;
  password: string;
  readyTimeout?: number;
  timeout?: number;
}

export interface ExecResult {
  stdout: string;
  stderr: string;
  exitCode: number;
}

export class SSHService extends EventEmitter {
  private config: SSHConfig;
  private conn: Client | null = null;

  constructor(config: SSHConfig) {
    super();
    this.config = {
      readyTimeout: 10000,
      timeout: 30000,
      ...config,
    };
  }

  /**
   * Connect to SSH server
   */
  connect(): Promise<void> {
    return new Promise((resolve, reject) => {
      this.conn = new Client();

      this.conn.on('ready', () => {
        resolve();
      }).on('error', (err) => {
        reject(new Error(`SSH connection failed: ${err.message}`));
      }).connect(this.config as ConnectConfig);
    });
  }

  /**
   * Execute a single command
   */
  exec(command: string): Promise<ExecResult> {
    return new Promise((resolve, reject) => {
      if (!this.conn) {
        reject(new Error('Not connected'));
        return;
      }

      this.conn.exec(command, (err, stream) => {
        if (err) {
          reject(err);
          return;
        }

        let stdout = '';
        let stderr = '';

        stream.on('close', (code, signal) => {
          resolve({
            stdout,
            stderr,
            exitCode: code || 0,
          });
        }).on('data', (data) => {
          stdout += data.toString();
        }).stderr.on('data', (data) => {
          stderr += data.toString();
        });
      });
    });
  }

  /**
   * Start an interactive shell session
   */
  shell(): Promise<ClientChannel> {
    return new Promise((resolve, reject) => {
      if (!this.conn) {
        reject(new Error('Not connected'));
        return;
      }

      this.conn.shell((err, stream) => {
        if (err) {
          reject(err);
          return;
        }
        resolve(stream);
      });
    });
  }

  /**
   * Close connection
   */
  disconnect(): void {
    if (this.conn) {
      this.conn.end();
      this.conn = null;
    }
  }
}
```

**Step 4: Run test to verify it passes**

Run: `cd apps/cli && npm test -- src/services/ssh.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add apps/cli/src/services/ssh.ts apps/cli/src/services/ssh.test.ts apps/cli/package.json
git commit -m "feat: add SSH service module for sandbox connection"
```

---

## Task 3: Implement Interactive Shell with PTY

**Files:**
- Create: `apps/cli/src/services/pty.ts`

**Step 1: Write the failing test**

```typescript
// apps/cli/src/services/pty.test.ts
import { PTYService } from './pty';

describe('PTYService', () => {
  it('should create PTY session', async () => {
    // This test will be skipped in CI as it requires a real PTY
  });
});
```

**Step 2: Run test to verify it fails**

Run: `cd apps/cli && npm test -- src/services/pty.test.ts`
Expected: FAIL (file does not exist)

**Step 3: Implement PTY service**

```typescript
// apps/cli/src/services/pty.ts
import * as pty from 'node-pty';
import { EventEmitter } from 'events';

export interface PTYConfig {
  command?: string;
  args?: string[];
  env?: Record<string, string>;
  cols?: number;
  rows?: number;
}

export class PTYService extends EventEmitter {
  private ptyProcess: pty.IPty | null = null;
  private readable: NodeJS.ReadableStream | null = null;
  private writable: NodeJS.WritableStream | null = null;

  /**
   * Start a PTY process
   */
  start(config: PTYConfig = {}): void {
    const { command = '/bin/sh', args = [], env = {}, cols = 80, rows = 24 } = config;

    this.ptyProcess = pty.spawn(command, args, {
      env: { ...process.env, ...env },
      cols,
      rows,
      name: 'xterm-color',
    });

    this.readable = this.ptyProcess;
    this.writable = this.ptyProcess;

    this.ptyProcess.on('data', (data) => {
      this.emit('data', data);
    });

    this.ptyProcess.on('exit', (code, signal) => {
      this.emit('exit', code, signal);
    });
  }

  /**
   * Write data to PTY
   */
  write(data: string): void {
    if (this.ptyProcess) {
      this.ptyProcess.write(data);
    }
  }

  /**
   * Resize PTY
   */
  resize(cols: number, rows: number): void {
    if (this.ptyProcess) {
      this.ptyProcess.resize(cols, rows);
    }
  }

  /**
   * Get readable stream
   */
  getReadable(): NodeJS.ReadableStream | null {
    return this.readable;
  }

  /**
   * Get writable stream
   */
   writable(): NodeJS.WritableStream | null {
    return this.writable;
  }

  /**
   * Kill PTY process
   */
  kill(signal?: string): void {
    if (this.ptyProcess) {
      this.ptyProcess.kill(signal || 'SIGTERM');
      this.ptyProcess = null;
    }
  }

  /**
   * Check if PTY is running
   */
  isRunning(): boolean {
    return this.ptyProcess !== null;
  }
}
```

**Step 4: Run test to verify it passes**

Run: `cd apps/cli && npm test -- src/services/pty.test.ts`
Expected: PASS (with skip)

**Step 5: Commit**

```bash
git add apps/cli/src/services/pty.ts apps/cli/src/services/pty.test.ts
git commit -m "feat: add PTY service for interactive shell"
```

---

## Task 4: Implement Enhanced SSH Command with Connection

**Files:**
- Modify: `apps/cli/src/commands/ssh.ts`

**Step 1: Write the failing test**

```typescript
// apps/cli/src/commands/ssh.test.ts
import { sshCmd } from './ssh';

describe('ssh command', () => {
  it('should require sandbox id', async () => {
    // Test argument validation
  });
});
```

**Step 2: Run test to verify it fails**

Run: `cd apps/cli && npm test -- src/commands/ssh.test.ts`
Expected: FAIL (test for new behavior)

**Step 3: Implement full SSH command**

```typescript
// apps/cli/src/commands/ssh.ts
import { Command } from 'commander';
import { APIClient } from '../api';
import { SSHService } from '../services/ssh';
import ora from 'ora';
import readline from 'readline';

interface SSHOptions {
  command?: string;
  interactive?: boolean;
}

export function sshCommand(): Command {
  const command = new Command('ssh <id>')
    .description('Connect to sandbox via SSH')
    .option('--command <cmd>', 'Execute command and exit')
    .option('--interactive', 'Force interactive mode', true)
    .action(async (id, options: SSHOptions) => {
      const spinner = ora('Connecting to sandbox...').start();

      try {
        // Get sandbox info
        const api = new APIClient();
        const sandbox = await api.getSandbox(id);

        if (!sandbox) {
          spinner.fail(`Sandbox not found: ${id}`);
          process.exit(1);
        }

        if (sandbox.status !== 'running') {
          spinner.fail(`Sandbox is not running (status: ${sandbox.status})`);
          process.exit(1);
        }

        spinner.succeed('Connected');

        // Get connection token
        const token = await api.getToken(id);

        // Connect via SSH
        await connectViaSSH(
          {
            host: sandbox.host,
            port: sandbox.port || 22,
            username: sandbox.user,
          },
          token,
          options
        );
      } catch (error: any) {
        spinner.fail(`Connection failed: ${error.message}`);
        process.exit(1);
      }
    });

  return command;
}

async function connectViaSSH(
  config: { host: string; port: number; username: string },
  token: string,
  options: SSHOptions
): Promise<void> {
  const ssh = new SSHService({
    host: config.host,
    port: config.port,
    username: config.username,
    password: token,
  });

  await ssh.connect();

  if (options.command) {
    // Execute single command
    const result = await ssh.exec(options.command);
    process.stdout.write(result.stdout);
    process.stderr.write(result.stderr);
    ssh.disconnect();
    process.exit(result.exitCode);
  } else {
    // Interactive shell
    console.log(`Connected to sandbox. Type 'exit' to disconnect.\n`);

    const stream = await ssh.shell();

    // Handle terminal
    process.stdin.setRawMode(true);
    stream.pipe(process.stdout);

    // Handle input
    process.stdin.pipe(stream);

    stream.on('close', () => {
      process.stdin.setRawMode(false);
      ssh.disconnect();
      process.exit(0);
    });

    // Handle resize
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
    });

    process.stdin.on('resize', () => {
      stream.setWindow(process.stdout.rows, process.stdout.columns, 0, 0);
    });
  }
}
```

**Step 4: Run test to verify it passes**

Run: `cd apps/cli && npm test -- src/commands/ssh.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add apps/cli/src/commands/ssh.ts apps/cli/src/commands/ssh.test.ts
git commit -m "feat: implement SSH connection in CLI command"
```

---

## Task 5: Update CLI Entry Point

**Files:**
- Modify: `apps/cli/src/index.ts`

**Step 1: Read current index.ts**

```bash
cat apps/cli/src/index.ts
```

**Step 2: Update to add ssh command**

```typescript
import { Command } from 'commander';
import { version } from './version';
import { configCommand } from './commands/configure';
import { sandboxCommand } from './commands';
import { sshCommand } from './commands/ssh';

const program = new Command();

program
  .name('codepod')
  .description('CodePod CLI - Sandbox management and code execution')
  .version(version);

program.addCommand(configCommand());
program.addCommand(sandboxCommand());
program.addCommand(sshCommand());

program.parse();
```

**Step 3: Verify build**

Run: `cd apps/cli && npm run build`
Expected: No errors

**Step 4: Commit**

```bash
git add apps/cli/src/index.ts
git commit -m "feat: add ssh command to CLI entry point"
```

---

## Task 6: Add Missing Sandbox Commands

**Files:**
- Create: `apps/cli/src/commands/get.ts`
- Create: `apps/cli/src/commands/stop.ts`
- Create: `apps/cli/src/commands/restart.ts`

**Step 1: Implement get command**

```typescript
// apps/cli/src/commands/get.ts
import { Command } from 'commander';
import { APIClient } from '../api';
import { formatStatus } from '../formatter';

export function getCommand(): Command {
  return new Command('get <id>')
    .description('Get sandbox details')
    .action(async (id) => {
      const api = new APIClient();
      const sandbox = await api.getSandbox(id);

      if (!sandbox) {
        console.error(`Sandbox not found: ${id}`);
        process.exit(1);
      }

      console.log(`\nSandbox: ${sandbox.name}`);
      console.log(`ID: ${sandbox.id}`);
      console.log(`Status: ${formatStatus(sandbox.status)}`);
      console.log(`Image: ${sandbox.image}`);
      console.log(`SSH: ${sandbox.user}@${sandbox.host}:${sandbox.port}`);
    });
}
```

**Step 2: Implement stop command**

```typescript
// apps/cli/src/commands/stop.ts
import { Command } from 'commander';
import { APIClient } from '../api';
import ora from 'ora';

export function stopCommand(): Command {
  return new Command('stop <id>')
    .description('Stop a running sandbox')
    .action(async (id) => {
      const spinner = ora('Stopping sandbox...').start();
      try {
        const api = new APIClient();
        await api.stopSandbox(id);
        spinner.succeed('Sandbox stopped');
      } catch (error: any) {
        spinner.fail(`Failed to stop sandbox: ${error.message}`);
        process.exit(1);
      }
    });
}
```

**Step 3: Implement restart command**

```typescript
// apps/cli/src/commands/restart.ts
import { Command } from 'commander';
import { APIClient } from '../api';
import ora from 'ora';

export function restartCommand(): Command {
  return new Command('restart <id>')
    .description('Restart a sandbox')
    .action(async (id) => {
      const spinner = ora('Restarting sandbox...').start();
      try {
        const api = new APIClient();
        await api.restartSandbox(id);
        spinner.succeed('Sandbox restarting');
      } catch (error: any) {
        spinner.fail(`Failed to restart sandbox: ${error.message}`);
        process.exit(1);
      }
    });
}
```

**Step 4: Add to sandbox command group**

```typescript
// apps/cli/src/commands/index.ts
import { Command } from 'commander';
import { createCommand } from './create';
import { listCommand } from './list';
import { getCommand } from './get';
import { deleteCommand } from './delete';
import { sshCommand } from './ssh';
import { stopCommand } from './stop';
import { restartCommand } from './restart';

export function sandboxCommand(): Command {
  const command = new Command('sandbox')
    .description('Manage sandboxes');

  command.addCommand(createCommand());
  command.addCommand(listCommand());
  command.addCommand(getCommand());
  command.addCommand(deleteCommand());
  command.addCommand(sshCommand());
  command.addCommand(stopCommand());
  command.addCommand(restartCommand());

  return command;
}
```

**Step 5: Add API methods**

```typescript
// apps/cli/src/api.ts
async stopSandbox(id: string): Promise<void> {
  await this.client.post(`/api/v1/sandboxes/${id}/stop`);
}

async restartSandbox(id: string): Promise<void> {
  await this.client.post(`/api/v1/sandboxes/${id}/restart`);
}
```

**Step 6: Run tests and commit**

```bash
cd apps/cli && npm test
git add apps/cli/src/commands/
git commit -m "feat: add get, stop, restart sandbox commands"
```

---

## Task 7: Integration Test

**Files:**
- Test against running sandbox

**Step 1: Build CLI**

```bash
cd apps/cli && npm run build
```

**Step 2: Create a test sandbox**

```bash
# Start server and runner first
cd docker && docker-compose up -d

# Create sandbox via API
curl -X POST http://localhost:8080/api/v1/sandboxes \
  -H "Content-Type: application/json" \
  -d '{"name": "test", "image": "python:3.11"}'
```

**Step 3: Test SSH connection**

```bash
# Get sandbox ID and test
./bin/codepod sandbox ssh <sandbox-id>
# Should connect to the sandbox

./bin/codepod sandbox ssh <sandbox-id> --command "python --version"
# Should execute command and exit
```

**Step 4: Test all commands**

```bash
./bin/codepod sandbox list
./bin/codepod sandbox get <id>
./bin/codepod sandbox stop <id>
./bin/codepod sandbox restart <id>
./bin/codepod sandbox delete <id>
```

---

## Summary

| Task | Description | Files |
|------|-------------|-------|
| 1 | Add SSH dependencies | package.json |
| 2 | Create SSH service | services/ssh.ts, ssh.test.ts |
| 3 | Create PTY service | services/pty.ts, pty.test.ts |
| 4 | Implement SSH command | commands/ssh.ts |
| 5 | Update CLI entry | index.ts |
| 6 | Add missing commands | commands/get.ts, stop.ts, restart.ts |
| 7 | Integration test | - |
